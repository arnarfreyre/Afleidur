<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forward & Options Payoff Plotter - Derivatives Course</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
        /* View toggle buttons */
        .view-toggle {
            display: flex;
            gap: 0;
            margin-bottom: 2rem;
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #e74c3c;
            width: fit-content;
        }

        .view-btn {
            padding: 0.75rem 2rem;
            background-color: white;
            color: #e74c3c;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .view-btn:hover {
            background-color: #fdeaea;
        }

        .view-btn.active {
            background-color: #e74c3c;
            color: white;
        }

        .view-btn:first-child {
            border-right: 1px solid #e74c3c;
        }

        /* Table styling */
        .payoff-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-family: Georgia, serif;
        }

        .payoff-table th,
        .payoff-table td {
            padding: 0.75rem;
            text-align: right;
            border: 1px solid #ddd;
        }

        .payoff-table th {
            background-color: #f8f8f8;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .payoff-table td {
            background-color: white;
        }

        .payoff-table tr:hover td {
            background-color: #f5f5f5;
        }

        .payoff-table td.positive {
            color: #27ae60;
        }

        .payoff-table td.negative {
            color: #e74c3c;
        }

        .table-controls {
            background-color: #f8f8f8;
            padding: 1.5rem;
            border-radius: 5px;
            margin-bottom: 1rem;
        }

        .table-wrapper {
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .custom-prices {
            background-color: #f8f8f8;
            padding: 1.5rem;
            border-radius: 5px;
        }

        .custom-prices h3 {
            margin-top: 0;
            color: #333;
        }

        /* Hide disabled contracts in table view */
        .contract-hidden {
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-header">
            <h1>Forward & Options Payoff Plotter</h1>
            <p>Interactive tool for plotting payoffs at maturity for forwards, calls, and puts with customizable positions</p>

            <!-- Navigation tabs -->
            <div class="nav-tabs">
                <a href="../index.html" class="nav-tab">Study Materials</a>
                <a href="../problem-sets.html" class="nav-tab">Problem Sets</a>
                <a href="../solvers.html" class="nav-tab active">Solvers</a>
            </div>
        </div>

        <a href="../solvers.html" class="back-to-main">‚Üê Back to Solvers</a>

        <!-- Contract Input Section -->
        <div class="plotter-section">
            <h2>Add Contract</h2>
            <div class="input-grid">
                <div class="input-group">
                    <label for="contractType">Contract Type</label>
                    <select id="contractType">
                        <option value="long-forward">Long Forward</option>
                        <option value="short-forward">Short Forward</option>
                        <option value="long-call">Long Call</option>
                        <option value="short-call">Short Call</option>
                        <option value="long-put">Long Put</option>
                        <option value="short-put">Short Put</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="strikePrice">Strike/Forward Price (K)</label>
                    <input type="number" id="strikePrice" value="100" step="1" min="0">
                </div>

                <div class="input-group">
                    <label for="quantity">Quantity/Multiplier</label>
                    <input type="number" id="quantity" value="1" step="0.1">
                </div>

                <div class="input-group">
                    <label for="premium">Premium (for options)</label>
                    <input type="number" id="premium" value="0" step="0.1" placeholder="0 for forwards">
                </div>
            </div>

            <div class="button-group">
                <button onclick="addContract()">Add Contract</button>
                <button class="btn-secondary" onclick="clearAllContracts()">Clear All</button>
            </div>
        </div>

        <!-- Contracts List -->
        <div class="plotter-section">
            <h2>Current Contracts</h2>
            <table class="contracts-table" id="contractsTable">
                <thead>
                    <tr>
                        <th>Visible</th>
                        <th>Type</th>
                        <th>Strike/Forward Price</th>
                        <th>Quantity</th>
                        <th>Premium</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="contractsList">
                    <tr>
                        <td colspan="6" class="empty-state">No contracts added yet</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Plot Controls -->
        <div class="plot-controls">
            <h2>Plot Settings</h2>

            <div class="visibility-controls">
                <label class="checkbox-label">
                    <input type="checkbox" id="showCombined" checked>
                    <span>Show Combined Payoff</span>
                </label>

                <label class="checkbox-label">
                    <input type="checkbox" id="showIndividual" checked>
                    <span>Show Individual Payoffs</span>
                </label>

                <label class="checkbox-label">
                    <input type="checkbox" id="showZeroLine" checked>
                    <span>Show Zero Line</span>
                </label>
            </div>

            <div class="input-grid">
                <div class="input-group">
                    <label for="minPrice">Min Stock Price</label>
                    <input type="number" id="minPrice" value="50" step="10">
                </div>

                <div class="input-group">
                    <label for="maxPrice">Max Stock Price</label>
                    <input type="number" id="maxPrice" value="150" step="10">
                </div>
            </div>

            <button onclick="generatePlot()" style="margin-top: 1.5rem;">Generate Plot</button>
        </div>

        <!-- View Toggle -->
        <div class="plotter-section">
            <div class="view-toggle">
                <button id="graphViewBtn" class="view-btn active" onclick="switchToGraphView()">Graph View</button>
                <button id="tableViewBtn" class="view-btn" onclick="switchToTableView()">Table View</button>
            </div>
        </div>

        <!-- Plot Display -->
        <div id="graphView" class="plotter-section">
            <h2>Payoff Diagram</h2>
            <div class="canvas-container">
                <canvas id="payoffChart" width="800" height="500"></canvas>
            </div>
            <div id="legend" class="legend" style="display: none;"></div>
        </div>

        <!-- Table Display -->
        <div id="tableView" class="plotter-section" style="display: none;">
            <h2>Payoff Values Table</h2>
            
            <div class="table-controls">
                <div class="input-grid">
                    <div class="input-group">
                        <label for="tableMinPrice">Start Price</label>
                        <input type="number" id="tableMinPrice" value="0" step="5">
                    </div>
                    <div class="input-group">
                        <label for="tableMaxPrice">End Price</label>
                        <input type="number" id="tableMaxPrice" value="30" step="5">
                    </div>
                    <div class="input-group">
                        <label for="tablePriceStep">Price Increment</label>
                        <input type="number" id="tablePriceStep" value="2" step="1" min="0.5">
                    </div>
                </div>
                <button onclick="generateTable()" style="margin-top: 1rem;">Update Table</button>
            </div>

            <div class="table-wrapper" style="margin-top: 2rem; overflow-x: auto;">
                <table id="payoffTable" class="payoff-table">
                    <thead>
                        <tr id="tableHeader">
                            <th>Stock Price</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                    </tbody>
                </table>
            </div>

            <div class="custom-prices" style="margin-top: 2rem;">
                <h3>Custom Price Points</h3>
                <div class="input-group">
                    <label for="customPrices">Enter custom prices (comma-separated)</label>
                    <input type="text" id="customPrices" placeholder="e.g., 10, 12, 15, 18, 20" style="width: 100%;">
                </div>
                <button onclick="generateCustomTable()" style="margin-top: 1rem;">Generate Custom Table</button>
            </div>
        </div>

        <div class="section">
            <h2>About Payoff Diagrams</h2>
            <p>
                Payoff diagrams are essential tools for understanding the profit and loss profiles of derivative positions.
                They show the value of a position at expiration as a function of the underlying asset's price.
            </p>

            <h3>Contract Types</h3>

            <div class="example">
                <h4>Forward Contracts</h4>
                <p><strong>Long Forward:</strong> Payoff = S<sub>T</sub> - K</p>
                <p><strong>Short Forward:</strong> Payoff = K - S<sub>T</sub></p>
            </div>

            <div class="example">
                <h4>Option Contracts</h4>
                <p><strong>Long Call:</strong> Payoff = max(S<sub>T</sub> - K, 0) - Premium</p>
                <p><strong>Short Call:</strong> Payoff = Premium - max(S<sub>T</sub> - K, 0)</p>
                <p><strong>Long Put:</strong> Payoff = max(K - S<sub>T</sub>, 0) - Premium</p>
                <p><strong>Short Put:</strong> Payoff = Premium - max(K - S<sub>T</sub>, 0)</p>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let contracts = [];
        const colors = ['#e74c3c', '#27ae60', '#f39c12', '#8e44ad', '#c0392b', '#16a085', '#d35400', '#2c3e50'];

        // Store plot data for hover functionality
        let plotData = {
            prices: [],
            combinedPayoffs: [],
            individualPayoffs: [],
            minPrice: 0,
            maxPrice: 0,
            yMin: 0,
            yMax: 0,
            padding: 60
        };

        // Contract management functions
        function addContract() {
            const type = document.getElementById('contractType').value;
            const strike = parseFloat(document.getElementById('strikePrice').value);
            const quantity = parseFloat(document.getElementById('quantity').value);
            const premium = parseFloat(document.getElementById('premium').value) || 0;

            if (isNaN(strike) || strike <= 0) {
                alert('Please enter a valid strike/forward price');
                return;
            }

            if (isNaN(quantity) || quantity === 0) {
                alert('Please enter a valid quantity');
                return;
            }

            contracts.push({
                type: type,
                strike: strike,
                quantity: quantity,
                premium: premium,
                color: colors[contracts.length % colors.length],
                visible: true // New property for visibility
            });

            updateContractsList();
        }

        function toggleContractVisibility(index) {
            contracts[index].visible = !contracts[index].visible;
            updateContractsList();
            
            // Update current view
            const currentView = document.getElementById('tableView').style.display;
            if (currentView === 'block') {
                generateTable();
            } else {
                generatePlot();
            }
        }

        function removeContract(index) {
            contracts.splice(index, 1);
            updateContractsList();
            
            const currentView = document.getElementById('tableView').style.display;
            if (contracts.length > 0) {
                if (currentView === 'block') {
                    generateTable();
                } else {
                    generatePlot();
                }
            } else {
                clearCanvas();
                // Clear table as well
                document.getElementById('tableBody').innerHTML = '<tr><td colspan="10" style="text-align: center;">No contracts to display</td></tr>';
            }
        }

        function clearAllContracts() {
            contracts = [];
            updateContractsList();
            clearCanvas();
        }

        function updateContractsList() {
            const tbody = document.getElementById('contractsList');

            if (contracts.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="empty-state">No contracts added yet</td></tr>';
                return;
            }

            tbody.innerHTML = contracts.map((contract, index) => `
                <tr class="${!contract.visible ? 'contract-hidden' : ''}">
                    <td>
                        <input type="checkbox"
                               class="visibility-checkbox"
                               ${contract.visible ? 'checked' : ''}
                               onchange="toggleContractVisibility(${index})">
                    </td>
                    <td>${formatContractType(contract.type)}</td>
                    <td>$${contract.strike.toFixed(2)}</td>
                    <td>${contract.quantity}</td>
                    <td>$${contract.premium.toFixed(2)}</td>
                    <td><button class="delete-btn" onclick="removeContract(${index})">Remove</button></td>
                </tr>
            `).join('');
        }

        function formatContractType(type) {
            return type.split('-').map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }

        // Payoff calculation functions
        function calculatePayoff(contract, stockPrice) {
            const S = stockPrice;
            const K = contract.strike;
            const Q = contract.quantity;
            const premium = contract.premium;

            let payoff = 0;

            switch(contract.type) {
                case 'long-forward':
                    payoff = Q * (S - K);
                    break;
                case 'short-forward':
                    payoff = Q * (K - S);
                    break;
                case 'long-call':
                    payoff = Q * (Math.max(S - K, 0) - premium);
                    break;
                case 'short-call':
                    payoff = Q * (-Math.max(S - K, 0) + premium);
                    break;
                case 'long-put':
                    payoff = Q * (Math.max(K - S, 0) - premium);
                    break;
                case 'short-put':
                    payoff = Q * (-Math.max(K - S, 0) + premium);
                    break;
            }

            return payoff;
        }

        // Plotting functions
        function generatePlot() {
            if (contracts.length === 0) {
                alert('Please add at least one contract');
                return;
            }

            const canvas = document.getElementById('payoffChart');
            const ctx = canvas.getContext('2d');

            const minPrice = parseFloat(document.getElementById('minPrice').value);
            const maxPrice = parseFloat(document.getElementById('maxPrice').value);
            const showIndividual = document.getElementById('showIndividual').checked;
            const showCombined = document.getElementById('showCombined').checked;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Generate data points
            const priceStep = (maxPrice - minPrice) / 200;
            const prices = [];
            const combinedPayoffs = [];
            const individualPayoffs = contracts.map(() => []);

            for (let price = minPrice; price <= maxPrice; price += priceStep) {
                prices.push(price);

                let combinedPayoff = 0;
                contracts.forEach((contract, index) => {
                    const payoff = contract.visible ? calculatePayoff(contract, price) : 0;
                    individualPayoffs[index].push(payoff);
                    combinedPayoff += payoff;
                });

                combinedPayoffs.push(combinedPayoff);
            }

            // Store plot data for hover functionality
            plotData = {
                prices: prices,
                combinedPayoffs: combinedPayoffs,
                individualPayoffs: individualPayoffs,
                minPrice: minPrice,
                maxPrice: maxPrice,
                padding: 60
            };

            // Find y-axis range
            let yMin = showCombined ? Math.min(...combinedPayoffs) : 0;
            let yMax = showCombined ? Math.max(...combinedPayoffs) : 0;

            if (showIndividual) {
                contracts.forEach((contract, index) => {
                    if (contract.visible) {
                        yMin = Math.min(yMin, ...individualPayoffs[index]);
                        yMax = Math.max(yMax, ...individualPayoffs[index]);
                    }
                });
            }

            // Add padding
            const yPadding = (yMax - yMin) * 0.1 || 10;
            yMin -= yPadding;
            yMax += yPadding;

            // Store y-axis range for hover calculations
            plotData.yMin = yMin;
            plotData.yMax = yMax;
            plotData.contracts = contracts.filter(c => c.visible);

            // Set up dimensions
            const padding = plotData.padding;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            // Draw axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;

            // X-axis
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.stroke();

            // Draw grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;

            // Horizontal grid lines
            for (let i = 0; i <= 10; i++) {
                const y = padding + (plotHeight * i / 10);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
            }

            // Vertical grid lines
            for (let i = 0; i <= 10; i++) {
                const x = padding + (plotWidth * i / 10);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
            }

            // Draw zero line if enabled
            const showZeroLine = document.getElementById('showZeroLine').checked;
            const zeroY = canvas.height - padding - ((0 - yMin) / (yMax - yMin)) * plotHeight;
            
            if (showZeroLine && zeroY >= padding && zeroY <= canvas.height - padding) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(padding, zeroY);
                ctx.lineTo(canvas.width - padding, zeroY);
                ctx.stroke();
            }

            // Transform functions
            const toX = (price) => padding + ((price - minPrice) / (maxPrice - minPrice)) * plotWidth;
            const toY = (payoff) => canvas.height - padding - ((payoff - yMin) / (yMax - yMin)) * plotHeight;

            // Draw individual payoffs if requested
            if (showIndividual) {
                contracts.forEach((contract, index) => {
                    if (contract.visible) {
                        ctx.strokeStyle = contract.color;
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.7;

                        ctx.beginPath();
                        ctx.moveTo(toX(prices[0]), toY(individualPayoffs[index][0]));

                        for (let i = 1; i < prices.length; i++) {
                            ctx.lineTo(toX(prices[i]), toY(individualPayoffs[index][i]));
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                });
            }

            // Draw combined payoff if requested
            if (showCombined) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(toX(prices[0]), toY(combinedPayoffs[0]));

                for (let i = 1; i < prices.length; i++) {
                    ctx.lineTo(toX(prices[i]), toY(combinedPayoffs[i]));
                }
                ctx.stroke();
            }

            // Mark strike prices
            const strikes = [...new Set(contracts.filter(c => c.visible).map(c => c.strike))];
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            strikes.forEach(strike => {
                if (strike >= minPrice && strike <= maxPrice) {
                    const x = toX(strike);
                    ctx.beginPath();
                    ctx.moveTo(x, padding);
                    ctx.lineTo(x, canvas.height - padding);
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '12px Georgia, serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`K=${strike}`, x, canvas.height - padding + 20);
                }
            });
            ctx.setLineDash([]);

            // Add labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Georgia, serif';

            // X-axis label
            ctx.textAlign = 'center';
            ctx.fillText('Stock Price at Maturity (S)', canvas.width / 2, canvas.height - 10);

            // Y-axis label
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Payoff ($)', 0, 0);
            ctx.restore();

            // Title
            ctx.font = 'bold 16px Georgia, serif';
            ctx.textAlign = 'center';
            ctx.fillText('Payoff Diagram', canvas.width / 2, 30);

            // Helper function to get nice tick values
            function getNiceTicks(min, max, targetCount) {
                const range = max - min;
                const roughStep = range / (targetCount - 1);
                
                // Find a nice step value
                const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
                const normalized = roughStep / magnitude;
                
                let niceStep;
                if (normalized <= 1) niceStep = magnitude;
                else if (normalized <= 2) niceStep = 2 * magnitude;
                else if (normalized <= 5) niceStep = 5 * magnitude;
                else niceStep = 10 * magnitude;
                
                // Calculate nice min and max
                const niceMin = Math.floor(min / niceStep) * niceStep;
                const niceMax = Math.ceil(max / niceStep) * niceStep;
                
                const ticks = [];
                for (let val = niceMin; val <= niceMax; val += niceStep) {
                    if (val >= min && val <= max) {
                        ticks.push(val);
                    }
                }
                
                return ticks;
            }

            // X-axis values
            ctx.font = '11px Georgia, serif';
            ctx.fillStyle = '#333';
            const xTicks = getNiceTicks(minPrice, maxPrice, 7);
            xTicks.forEach(price => {
                const x = toX(price);
                ctx.textAlign = 'center';
                const label = price % 1 === 0 ? price.toString() : price.toFixed(1);
                ctx.fillText(`$${label}`, x, canvas.height - padding + 35);
            });

            // Y-axis values
            ctx.textAlign = 'right';
            const yTicks = getNiceTicks(yMin, yMax, 7);
            yTicks.forEach(payoff => {
                const y = toY(payoff);
                const label = Math.abs(payoff) < 0.01 ? '0' : 
                              payoff % 1 === 0 ? payoff.toString() : payoff.toFixed(1);
                ctx.fillText(`$${label}`, padding - 10, y + 4);
            });
            
            // Add y=0 label specifically if zero line is shown
            if (showZeroLine && zeroY >= padding && zeroY <= canvas.height - padding) {
                ctx.fillStyle = '#000';
                ctx.font = 'bold 11px Georgia, serif';
                ctx.fillText('$0', padding - 10, zeroY + 4);
            }

            // Update legend
            updateLegend();
        }

        function updateLegend() {
            const legendDiv = document.getElementById('legend');

            if (contracts.length === 0) {
                legendDiv.style.display = 'none';
                return;
            }

            legendDiv.style.display = 'block';
            legendDiv.innerHTML = '<h3>Legend</h3>';

            // Combined payoff
            if (document.getElementById('showCombined').checked) {
                legendDiv.innerHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #333; height: 4px;"></div>
                        <span><strong>Combined Payoff</strong></span>
                    </div>
                `;
            }

            // Individual contracts
            contracts.forEach((contract, index) => {
                legendDiv.innerHTML += `
                    <div class="legend-item ${!contract.visible ? 'disabled' : ''}" onclick="toggleContractVisibility(${index})">
                        <div class="legend-color" style="background-color: ${contract.color};"></div>
                        <span>${formatContractType(contract.type)} (K=$${contract.strike}, Q=${contract.quantity})</span>
                    </div>
                `;
            });
        }

        function clearCanvas() {
            const canvas = document.getElementById('payoffChart');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('legend').style.display = 'none';
            plotData = {
                prices: [],
                combinedPayoffs: [],
                individualPayoffs: [],
                minPrice: 0,
                maxPrice: 0,
                yMin: 0,
                yMax: 0,
                padding: 60
            };
        }

        // View switching functions
        function switchToGraphView() {
            document.getElementById('graphView').style.display = 'block';
            document.getElementById('tableView').style.display = 'none';
            document.getElementById('graphViewBtn').classList.add('active');
            document.getElementById('tableViewBtn').classList.remove('active');
            if (contracts.length > 0) {
                generatePlot();
            }
        }

        function switchToTableView() {
            document.getElementById('graphView').style.display = 'none';
            document.getElementById('tableView').style.display = 'block';
            document.getElementById('graphViewBtn').classList.remove('active');
            document.getElementById('tableViewBtn').classList.add('active');
            if (contracts.length > 0) {
                generateTable();
            }
        }

        // Table generation functions
        function generateTable() {
            if (contracts.length === 0) {
                alert('Please add at least one contract');
                return;
            }

            const minPrice = parseFloat(document.getElementById('tableMinPrice').value);
            const maxPrice = parseFloat(document.getElementById('tableMaxPrice').value);
            const priceStep = parseFloat(document.getElementById('tablePriceStep').value);

            if (minPrice >= maxPrice) {
                alert('End price must be greater than start price');
                return;
            }

            const prices = [];
            for (let price = minPrice; price <= maxPrice; price += priceStep) {
                prices.push(price);
            }

            buildPayoffTable(prices);
        }

        function generateCustomTable() {
            if (contracts.length === 0) {
                alert('Please add at least one contract');
                return;
            }

            const customPricesInput = document.getElementById('customPrices').value;
            if (!customPricesInput.trim()) {
                alert('Please enter custom prices');
                return;
            }

            const prices = customPricesInput.split(',').map(p => parseFloat(p.trim())).filter(p => !isNaN(p));
            if (prices.length === 0) {
                alert('Please enter valid numeric prices');
                return;
            }

            prices.sort((a, b) => a - b);
            buildPayoffTable(prices);
        }

        function buildPayoffTable(prices) {
            const header = document.getElementById('tableHeader');
            const body = document.getElementById('tableBody');
            
            // Build header
            let headerHTML = '<th>Stock Price</th>';
            
            // Add columns for visible contracts
            const visibleContracts = contracts.filter(c => c.visible);
            visibleContracts.forEach(contract => {
                headerHTML += `<th style="color: ${contract.color};">${formatContractType(contract.type)}<br>(K=$${contract.strike}, Q=${contract.quantity})</th>`;
            });
            
            // Add combined column if enabled
            if (document.getElementById('showCombined').checked) {
                headerHTML += '<th style="font-weight: bold;">Combined</th>';
            }
            
            header.innerHTML = headerHTML;
            
            // Build table body
            let bodyHTML = '';
            
            prices.forEach(price => {
                bodyHTML += '<tr>';
                bodyHTML += `<td style="font-weight: bold;">$${price.toFixed(2)}</td>`;
                
                let combinedPayoff = 0;
                
                // Calculate payoffs for visible contracts
                visibleContracts.forEach(contract => {
                    const payoff = calculatePayoff(contract, price);
                    combinedPayoff += payoff;
                    const colorClass = payoff >= 0 ? 'positive' : 'negative';
                    bodyHTML += `<td class="${colorClass}">$${payoff.toFixed(2)}</td>`;
                });
                
                // Add combined payoff if enabled
                if (document.getElementById('showCombined').checked) {
                    const colorClass = combinedPayoff >= 0 ? 'positive' : 'negative';
                    bodyHTML += `<td class="${colorClass}" style="font-weight: bold;">$${combinedPayoff.toFixed(2)}</td>`;
                }
                
                bodyHTML += '</tr>';
            });
            
            body.innerHTML = bodyHTML;
        }

        // Initialize with example from the problem
        window.addEventListener('DOMContentLoaded', function() {
            // Add event listeners for plot settings changes
            document.getElementById('showCombined').addEventListener('change', function() {
                const currentView = document.getElementById('tableView').style.display;
                if (currentView === 'block') {
                    generateTable();
                } else {
                    generatePlot();
                }
            });
            document.getElementById('showIndividual').addEventListener('change', generatePlot);
            document.getElementById('showZeroLine').addEventListener('change', generatePlot);

            // Add the three contracts from the example problem
            contracts = [
                { type: 'long-forward', strike: 12, quantity: 1, premium: 0, color: colors[0], visible: true },
                { type: 'short-forward', strike: 15, quantity: 1, premium: 0, color: colors[1], visible: true },
                { type: 'long-call', strike: 20, quantity: 0.3, premium: 0, color: colors[2], visible: true }
            ];

            // Update the display
            updateContractsList();

            // Set appropriate price range
            document.getElementById('minPrice').value = 0;
            document.getElementById('maxPrice').value = 30;
            
            // Set default table values
            document.getElementById('tableMinPrice').value = 0;
            document.getElementById('tableMaxPrice').value = 30;
            document.getElementById('tablePriceStep').value = 2;

            // Generate the initial plot
            generatePlot();
        });
    </script>
</body>
</html>